//
//  ActivityTrackingViewModel.swift
//  Taqvo
//
//  Generated by Assistant on 10/17/25
//

import Foundation
import CoreLocation
import MapKit
import UIKit

enum ActivityKind: String, Codable { case walk, jog, run, ride }

struct RouteSample {
    let latitude: Double
    let longitude: Double
    let timestamp: Date
}

struct ActivitySummary {
    let distanceMeters: Double
    let durationSeconds: Double
    let route: [CLLocationCoordinate2D]
    let routeSamples: [RouteSample]
    let startDate: Date
    let endDate: Date
    let kind: ActivityKind
    let caloriesKilocalories: Double
    // Challenge metadata (optional)
    let linkedChallengeTitle: String?
    let linkedChallengeIsPublic: Bool?

    init(distanceMeters: Double,
         durationSeconds: Double,
         route: [CLLocationCoordinate2D],
         routeSamples: [RouteSample],
         startDate: Date,
         endDate: Date,
         kind: ActivityKind,
         caloriesKilocalories: Double,
         linkedChallengeTitle: String? = nil,
         linkedChallengeIsPublic: Bool? = nil) {
        self.distanceMeters = distanceMeters
        self.durationSeconds = durationSeconds
        self.route = route
        self.routeSamples = routeSamples
        self.startDate = startDate
        self.endDate = endDate
        self.kind = kind
        self.caloriesKilocalories = caloriesKilocalories
        self.linkedChallengeTitle = linkedChallengeTitle
        self.linkedChallengeIsPublic = linkedChallengeIsPublic
    }
}

import CoreMotion

final class ActivityTrackingViewModel: NSObject, ObservableObject, CLLocationManagerDelegate {
    @Published var isRunning: Bool = false
    @Published var distanceMeters: Double = 0
    @Published var durationSeconds: Double = 0
    @Published var routeCoordinates: [CLLocationCoordinate2D] = []
    @Published var autoPauseEnabled: Bool = true
    @Published var timeGoalSeconds: Double?
    @Published var distanceGoalMeters: Double?
    @Published var goalReached: Bool = false
    @Published var autoEndOnGoal: Bool = false
    @Published var activityKind: ActivityKind = .run
    private let locationManager = CLLocationManager()
    private var locations: [CLLocation] = []
    private var timer: Timer?
    private var startDate: Date?
    private var nextHapticMeters: Double = 1000.0
    private let haptic = UINotificationFeedbackGenerator()
    private var pendingStart: Bool = false
    private let smoothAlpha: Double = 0.25
    private let minAppendDistanceMeters: Double = 1.0
    private let maxJumpMeters: Double = 200.0
    private let maxAcceptableAccuracyMeters: Double = 25.0
    private var pauseDate: Date?
    // Auto-pause state
    private var motionManager: CMMotionActivityManager?
    private var motionStationary: Bool = false
    private var motionWalkingOrRunning: Bool = false
    private var autoPaused: Bool = false
    private var manualPaused: Bool = false
    private var lowSpeedStart: Date?
    private var highSpeedStart: Date?
    private var lowSpeedThreshold: Double = 0.7
    private var resumeSpeedThreshold: Double = 0.8
    private var minLowSpeedDurationToPause: TimeInterval = 3
    private var minHighSpeedDurationToResume: TimeInterval = 2
    private let minSessionSecondsForAutoPause: TimeInterval = 10

    var hasSession: Bool { startDate != nil }

    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = minAppendDistanceMeters
        locationManager.pausesLocationUpdatesAutomatically = false
        locationManager.showsBackgroundLocationIndicator = true
    }

    func start() {
        guard !isRunning else { return }
        // Avoid synchronous CoreLocation queries on the main thread.
        // Drive session start based on current authorization and delegate callbacks.
        let status = locationManager.authorizationStatus
        switch status {
        case .authorizedAlways, .authorizedWhenInUse:
            pendingStart = false
            beginSession()
            if status == .authorizedWhenInUse {
                // Escalate to Always to allow background tracking mid-run
                locationManager.requestAlwaysAuthorization()
            }
        case .notDetermined:
            pendingStart = true
            locationManager.requestWhenInUseAuthorization()
        default:
            // Denied / restricted; do not start. UI should reflect permission state.
            pendingStart = false
        }
    }

    private func startTimer() {
        timer?.invalidate()
        guard let start = startDate else { return }
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] _ in
            guard let self = self, self.isRunning else { return }
            self.durationSeconds = Date().timeIntervalSince(start)
            // Goal: time-based
            if !self.goalReached, let tg = self.timeGoalSeconds, self.durationSeconds >= tg {
                self.goalReached = true
                self.haptic.notificationOccurred(.success)
            }
        }
    }

    private func beginSession() {
        locations = []
        routeCoordinates = []
        distanceMeters = 0
        durationSeconds = 0
        startDate = Date()
        isRunning = true
        goalReached = false
        nextHapticMeters = 1000.0
        haptic.prepare()
        startMotionUpdates()
        locationManager.allowsBackgroundLocationUpdates = true
        locationManager.startUpdatingLocation()
        startTimer()
    }

    func stop() {
        guard isRunning else { return }
        isRunning = false
        locationManager.stopUpdatingLocation()
        locationManager.allowsBackgroundLocationUpdates = false
        timer?.invalidate()
        timer = nil
        startDate = nil
        pauseDate = nil
        stopMotionUpdates()
        autoPaused = false
        manualPaused = false
        lowSpeedStart = nil
        highSpeedStart = nil
    }

    func pause() {
        guard isRunning else { return }
        manualPaused = true
        isRunning = false
        pauseDate = Date()
        locationManager.stopUpdatingLocation()
        timer?.invalidate()
        timer = nil
    }

    func resume() {
        guard !isRunning, let sd = startDate else { return }
        if let pd = pauseDate {
            let pausedInterval = Date().timeIntervalSince(pd)
            startDate = sd.addingTimeInterval(pausedInterval)
            pauseDate = nil
        }
        manualPaused = false
        autoPaused = false
        // Reset windows to avoid sticky states after resume
        lowSpeedStart = nil
        highSpeedStart = nil
        isRunning = true
        locationManager.startUpdatingLocation()
        startTimer()
    }

    // Remove deprecated didChangeAuthorization(status:) in favor of locationManagerDidChangeAuthorization(_:)
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        let status = manager.authorizationStatus
        if (status == .authorizedAlways || status == .authorizedWhenInUse) && pendingStart {
            pendingStart = false
            beginSession()
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations newLocations: [CLLocation]) {
        guard !newLocations.isEmpty else { return }
        if isRunning {
            for loc in newLocations {
                guard loc.horizontalAccuracy > 0, loc.horizontalAccuracy <= maxAcceptableAccuracyMeters else { continue }
                if let last = locations.last {
                    let delta = loc.distance(from: last)
                    guard delta >= minAppendDistanceMeters && delta <= maxJumpMeters else { continue }
                    distanceMeters += delta
                    // Goal: distance-based
                    if !goalReached, let dg = distanceGoalMeters, distanceMeters >= dg {
                        goalReached = true
                        haptic.notificationOccurred(.success)
                    }
                } else {
                    routeCoordinates.append(loc.coordinate)
                }
                // Append raw and smoothed route
                locations.append(loc)
                let smoothed = smoothedCoordinate(for: loc.coordinate)
                routeCoordinates.append(smoothed)
                if distanceMeters >= nextHapticMeters {
                    haptic.notificationOccurred(.success)
                    nextHapticMeters += 1000
                }
                // Auto-pause/resume based on speed and motion
                let speed = loc.speed // -1 if invalid
                tryAutoPauseResumeConsiderSpeed(speed, timestamp: loc.timestamp)
            }
        } else {
            // When paused, do not mutate route; still use location speed to attempt auto-resume
            for loc in newLocations {
                guard loc.horizontalAccuracy > 0, loc.horizontalAccuracy <= maxAcceptableAccuracyMeters else { continue }
                tryAutoPauseResumeConsiderSpeed(loc.speed, timestamp: loc.timestamp)
            }
        }
    }

    private func internalAutoPause() {
        guard isRunning else { return }
        autoPaused = true
        isRunning = false
        pauseDate = Date()
        // Keep location updates running so we can detect movement for auto-resume
        // locationManager.stopUpdatingLocation()
        timer?.invalidate()
        timer = nil
    }
    func setActivityKind(_ kind: ActivityKind) {
        activityKind = kind
        configureThresholdsForKind(kind)
    }

    private func configureThresholdsForKind(_ kind: ActivityKind) {
        switch kind {
        case .walk:
            lowSpeedThreshold = 0.5
            resumeSpeedThreshold = 0.6
            minLowSpeedDurationToPause = 5
            minHighSpeedDurationToResume = 3
        case .jog:
            lowSpeedThreshold = 0.8
            resumeSpeedThreshold = 1.2
            minLowSpeedDurationToPause = 3
            minHighSpeedDurationToResume = 2
        case .run:
            lowSpeedThreshold = 1.4
            resumeSpeedThreshold = 2.0
            minLowSpeedDurationToPause = 3
            minHighSpeedDurationToResume = 2
        case .ride:
            lowSpeedThreshold = 2.0
            resumeSpeedThreshold = 3.0
            minLowSpeedDurationToPause = 2
            minHighSpeedDurationToResume = 2
        }
    }

    private func tryAutoPauseResumeConsiderSpeed(_ speed: Double, timestamp: Date) {
        guard autoPauseEnabled, startDate != nil else { return }
        if durationSeconds < minSessionSecondsForAutoPause { return }

        let belowLow = (speed >= 0 && speed < lowSpeedThreshold) || (speed < 0 && motionStationary)
        let aboveHigh = (speed >= resumeSpeedThreshold) || motionWalkingOrRunning

        if manualPaused { lowSpeedStart = nil; highSpeedStart = nil; return }

        if autoPaused {
            if aboveHigh {
                if highSpeedStart == nil { highSpeedStart = timestamp }
                if let hs = highSpeedStart, timestamp.timeIntervalSince(hs) >= minHighSpeedDurationToResume {
                    resume()
                }
            } else {
                highSpeedStart = nil
            }
        } else {
            if belowLow {
                if lowSpeedStart == nil { lowSpeedStart = timestamp }
                if let ls = lowSpeedStart, timestamp.timeIntervalSince(ls) >= minLowSpeedDurationToPause {
                    internalAutoPause()
                }
            } else {
                lowSpeedStart = nil
            }
        }
    }
    private func smoothedCoordinate(for new: CLLocationCoordinate2D) -> CLLocationCoordinate2D {
        if let last = routeCoordinates.last {
            let lat = last.latitude + smoothAlpha * (new.latitude - last.latitude)
            let lon = last.longitude + smoothAlpha * (new.longitude - last.longitude)
            return CLLocationCoordinate2D(latitude: lat, longitude: lon)
        } else {
            return new
        }
    }

    func summary() -> ActivitySummary {
        let samples: [RouteSample] = locations.map { loc in
            RouteSample(latitude: loc.coordinate.latitude,
                        longitude: loc.coordinate.longitude,
                        timestamp: loc.timestamp)
        }
        return ActivitySummary(
            distanceMeters: distanceMeters,
            durationSeconds: durationSeconds,
            route: routeCoordinates,
            routeSamples: samples,
            startDate: startDate ?? Date(),
            endDate: Date(),
            kind: activityKind,
            caloriesKilocalories: estimateCalories()
        )
    }

    private func estimateCalories() -> Double {
        // Simple MET-based estimate; refine later with HealthKit data
        // MET values approximate: walk 3.5, jog 7.0, run 9.8, ride 8.0
        let met: Double
        switch activityKind {
        case .walk: met = 3.5
        case .jog: met = 7.0
        case .run: met = 9.8
        case .ride: met = 8.0
        }
        // Assume body mass 70kg if not available; kcal = MET * 3.5 * weight(kg)/200 * minutes
        let weightKg: Double = 70
        let minutes = max(durationSeconds, 0) / 60.0
        let kcal = met * 3.5 * weightKg / 200.0 * minutes
        return max(kcal, 0)
    }

    static func formattedPace(distanceMeters: Double, durationSeconds: Double) -> String {
        guard distanceMeters > 1, durationSeconds > 0 else { return "--" }
        let paceSecPerKm = durationSeconds / (distanceMeters / 1000.0)
        let minutes = Int(paceSecPerKm) / 60
        let seconds = Int(paceSecPerKm) % 60
        return String(format: "%d:%02d min/km", minutes, seconds)
    }

    static func formattedDuration(_ seconds: Double) -> String {
        let s = Int(seconds)
        let h = s / 3600
        let m = (s % 3600) / 60
        let sec = s % 60
        if h > 0 { return String(format: "%d:%02d:%02d", h, m, sec) }
        return String(format: "%02d:%02d", m, sec)
    }

    // Goal progress helpers
    func goalProgressFraction() -> Double {
        if let dg = distanceGoalMeters, dg > 0 {
            return min(max(distanceMeters / dg, 0), 1)
        }
        if let tg = timeGoalSeconds, tg > 0 {
            return min(max(durationSeconds / tg, 0), 1)
        }
        return 0
    }

    func goalProgressText() -> String {
        if let dg = distanceGoalMeters {
            return String(format: "%.2f km of %.2f km", distanceMeters / 1000.0, dg / 1000.0)
        }
        if let tg = timeGoalSeconds {
            return "\(ActivityTrackingViewModel.formattedDuration(durationSeconds)) of \(ActivityTrackingViewModel.formattedDuration(tg))"
        }
        return "No goal"
    }

    func goalRemainingEstimateText() -> String {
        if let dg = distanceGoalMeters {
            let remainingMeters = max(dg - distanceMeters, 0)
            let secPerMeter = distanceMeters > 1 ? durationSeconds / distanceMeters : 0
            let estimatedSeconds = secPerMeter > 0 ? remainingMeters * secPerMeter : 0
            let remainDistStr = String(format: "%.2f km left", remainingMeters / 1000.0)
            let estimateStr = estimatedSeconds > 0 ? " (~\(ActivityTrackingViewModel.formattedDuration(estimatedSeconds)))" : ""
            return remainDistStr + estimateStr
        }
        if let tg = timeGoalSeconds {
            let remainingSeconds = max(tg - durationSeconds, 0)
            let secPerMeter = distanceMeters > 1 ? durationSeconds / distanceMeters : 0
            let estimatedMeters = secPerMeter > 0 ? remainingSeconds / secPerMeter : 0
            let remainTimeStr = "\(ActivityTrackingViewModel.formattedDuration(remainingSeconds)) left"
            let estimateStr = estimatedMeters > 0 ? String(format: " (~%.2f km)", estimatedMeters / 1000.0) : ""
            return remainTimeStr + estimateStr
        }
        return ""
    }

    func goalEstimatedFinishTimeText() -> String {
        guard let dg = distanceGoalMeters else { return "" }
        let remainingMeters = max(dg - distanceMeters, 0)
        let secPerMeter = distanceMeters > 1 ? durationSeconds / distanceMeters : 0
        let estimatedSeconds = secPerMeter > 0 ? remainingMeters * secPerMeter : 0
        guard estimatedSeconds > 0 else { return "" }
        let finish = Date().addingTimeInterval(estimatedSeconds)
        return finish.formatted(date: .omitted, time: .shortened)
    }

    private func startMotionUpdates() {
        guard CMMotionActivityManager.isActivityAvailable() else { return }
        if motionManager == nil { motionManager = CMMotionActivityManager() }
        motionManager?.startActivityUpdates(to: OperationQueue.main) { [weak self] activity in
            guard let self = self, let a = activity else { return }
            self.motionStationary = a.stationary || a.unknown
            self.motionWalkingOrRunning = a.walking || a.running
            self.tryAutoPauseResumeConsiderSpeed(-1, timestamp: Date())
        }
    }

    private func stopMotionUpdates() {
        motionManager?.stopActivityUpdates()
        motionStationary = false
        motionWalkingOrRunning = false
    }
    func setTimeGoal(_ seconds: Double?) { timeGoalSeconds = seconds }
    func setDistanceGoal(_ meters: Double?) { distanceGoalMeters = meters }
}

extension ActivitySummary {
    func withChallenge(title: String?, isPublic: Bool?) -> ActivitySummary {
        ActivitySummary(
            distanceMeters: self.distanceMeters,
            durationSeconds: self.durationSeconds,
            route: self.route,
            routeSamples: self.routeSamples,
            startDate: self.startDate,
            endDate: self.endDate,
            kind: self.kind,
            caloriesKilocalories: self.caloriesKilocalories,
            linkedChallengeTitle: title,
            linkedChallengeIsPublic: isPublic
        )
    }
}