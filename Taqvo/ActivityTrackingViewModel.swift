//
//  ActivityTrackingViewModel.swift
//  Taqvo
//
//  Generated by Assistant on 10/17/25
//

import Foundation
import CoreLocation
import MapKit
import UIKit

enum ActivityKind: String, Codable, Hashable { 
    case walk
    case run
    case trailRun = "trail run"
    case hiking
}

struct RouteSample {
    let latitude: Double
    let longitude: Double
    let timestamp: Date
}

struct ActivityMarker: Identifiable, Codable {
    let id: UUID
    let latitude: Double
    let longitude: Double
    let timestamp: Date
    let note: String?
    let photoPNG: Data?

    var coordinate: CLLocationCoordinate2D { CLLocationCoordinate2D(latitude: latitude, longitude: longitude) }
}
struct ActivitySummary {
    let distanceMeters: Double
    let durationSeconds: Double
    let route: [CLLocationCoordinate2D]
    let routeSamples: [RouteSample]
    let startDate: Date
    let endDate: Date
    let kind: ActivityKind
    let caloriesKilocalories: Double
    let activeCaloriesKilocalories: Double
    let stepsCount: Int?
    let elevationGainMeters: Double?
    let elevationLossMeters: Double?
    let avgCadenceSPM: Double?
    let avgHeartRateBPM: Double?
    let avgStrideMeters: Double?
    // Challenge metadata (optional)
    let linkedChallengeTitle: String?
    let linkedChallengeIsPublic: Bool?

    init(distanceMeters: Double,
         durationSeconds: Double,
         route: [CLLocationCoordinate2D],
         routeSamples: [RouteSample],
         startDate: Date,
         endDate: Date,
         kind: ActivityKind,
         caloriesKilocalories: Double,
         activeCaloriesKilocalories: Double,
         stepsCount: Int? = nil,
         elevationGainMeters: Double? = nil,
         elevationLossMeters: Double? = nil,
         avgCadenceSPM: Double? = nil,
         avgHeartRateBPM: Double? = nil,
         avgStrideMeters: Double? = nil,
         linkedChallengeTitle: String? = nil,
         linkedChallengeIsPublic: Bool? = nil) {
        self.distanceMeters = distanceMeters
        self.durationSeconds = durationSeconds
        self.route = route
        self.routeSamples = routeSamples
        self.startDate = startDate
        self.endDate = endDate
        self.kind = kind
        self.caloriesKilocalories = caloriesKilocalories
        self.activeCaloriesKilocalories = activeCaloriesKilocalories
        self.stepsCount = stepsCount
        self.elevationGainMeters = elevationGainMeters
        self.elevationLossMeters = elevationLossMeters
        self.avgCadenceSPM = avgCadenceSPM
        self.avgHeartRateBPM = avgHeartRateBPM
        self.avgStrideMeters = avgStrideMeters
        self.linkedChallengeTitle = linkedChallengeTitle
        self.linkedChallengeIsPublic = linkedChallengeIsPublic
    }
}

import CoreMotion

final class ActivityTrackingViewModel: NSObject, ObservableObject, CLLocationManagerDelegate {
    @Published var isRunning: Bool = false
    @Published var distanceMeters: Double = 0
    @Published var durationSeconds: Double = 0
    @Published var routeCoordinates: [CLLocationCoordinate2D] = []
    @Published var autoPauseEnabled: Bool = true
    @Published var timeGoalSeconds: Double?
    @Published var distanceGoalMeters: Double?
    @Published var goalReached: Bool = false
    @Published var autoEndOnGoal: Bool = false
    @Published var activityKind: ActivityKind = .run
    // Live metrics
    @Published var currentCadenceSPM: Double? = nil
    @Published var elevationGainMeters: Double = 0
    @Published var elevationLossMeters: Double = 0
    // In-run markers
    @Published var markers: [ActivityMarker] = []
    // Live steps
    @Published var totalSteps: Int = 0
    
    // Tracking for averages
    private var cadenceSamples: [Double] = []
    private var heartRateSamples: [Double] = []

    private let locationManager = CLLocationManager()
    private var locations: [CLLocation] = []
    private var timer: Timer?
    private var startDate: Date?
    private var nextHapticMeters: Double = 1000.0
    private let haptic = UINotificationFeedbackGenerator()
    private var pendingStart: Bool = false
    private let smoothAlpha: Double = 0.25
    private let minAppendDistanceMeters: Double = 1.0
    private let maxJumpMeters: Double = 200.0
    private let maxAcceptableAccuracyMeters: Double = 25.0
    private var pauseDate: Date?
    // Auto-pause state
    private var motionManager: CMMotionActivityManager?
    private var motionStationary: Bool = false
    private var motionWalkingOrRunning: Bool = false
    private var autoPaused: Bool = false
    private var manualPaused: Bool = false
    private var lowSpeedStart: Date?
    private var highSpeedStart: Date?
    private var lowSpeedThreshold: Double = 0.7
    private var resumeSpeedThreshold: Double = 0.8
    private var minLowSpeedDurationToPause: TimeInterval = 3
    private var minHighSpeedDurationToResume: TimeInterval = 2
    private let minSessionSecondsForAutoPause: TimeInterval = 10

    // Pedometer for cadence/steps
    private var pedometer = CMPedometer()
    private var lastAltitude: Double?
    private let minElevationDeltaMeters: Double = 0.5

    var hasSession: Bool { startDate != nil }

    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = minAppendDistanceMeters
        locationManager.pausesLocationUpdatesAutomatically = false
        locationManager.showsBackgroundLocationIndicator = true
    }

    func start() {
        guard !isRunning else { return }
        // Avoid synchronous CoreLocation queries on the main thread.
        // Drive session start based on current authorization and delegate callbacks.
        let status = locationManager.authorizationStatus
        switch status {
        case .authorizedAlways, .authorizedWhenInUse:
            pendingStart = false
            beginSession()
            if status == .authorizedWhenInUse {
                // Escalate to Always to allow background tracking mid-run
                locationManager.requestAlwaysAuthorization()
            }
        case .notDetermined:
            pendingStart = true
            locationManager.requestWhenInUseAuthorization()
        default:
            // Denied / restricted; do not start. UI should reflect permission state.
            pendingStart = false
        }
    }

    private func startTimer() {
        timer?.invalidate()
        guard let start = startDate else { return }
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] _ in
            guard let self = self, self.isRunning else { return }
            self.durationSeconds = Date().timeIntervalSince(start)
            // Goal: time-based
            if !self.goalReached, let tg = self.timeGoalSeconds, self.durationSeconds >= tg {
                self.goalReached = true
                self.haptic.notificationOccurred(.success)
            }
        }
    }

    private func beginSession() {
        locations = []
        routeCoordinates = []
        distanceMeters = 0
        durationSeconds = 0
        elevationGainMeters = 0
        elevationLossMeters = 0
        lastAltitude = nil
        markers = []
        totalSteps = 0
        cadenceSamples = []
        heartRateSamples = []
        startDate = Date()
        isRunning = true
        goalReached = false
        nextHapticMeters = 1000.0
        haptic.prepare()
        startMotionUpdates()
        startPedometerUpdates()
        locationManager.allowsBackgroundLocationUpdates = true
        locationManager.startUpdatingLocation()
        startTimer()
    }

    func stop() {
        guard isRunning else { return }
        isRunning = false
        locationManager.stopUpdatingLocation()
        locationManager.allowsBackgroundLocationUpdates = false
        timer?.invalidate()
        timer = nil
        startDate = nil
        pauseDate = nil
        stopMotionUpdates()
        stopPedometerUpdates()
        autoPaused = false
        manualPaused = false
        lowSpeedStart = nil
        highSpeedStart = nil
    }

    func pause() {
        guard isRunning else { return }
        manualPaused = true
        isRunning = false
        pauseDate = Date()
        locationManager.stopUpdatingLocation()
        timer?.invalidate()
        timer = nil
    }

    func resume() {
        guard !isRunning, let sd = startDate else { return }
        if let pd = pauseDate {
            let pausedInterval = Date().timeIntervalSince(pd)
            startDate = sd.addingTimeInterval(pausedInterval)
            pauseDate = nil
        }
        manualPaused = false
        autoPaused = false
        // Reset windows to avoid sticky states after resume
        lowSpeedStart = nil
        highSpeedStart = nil
        isRunning = true
        locationManager.startUpdatingLocation()
        startTimer()
    }

    // Remove deprecated didChangeAuthorization(status:) in favor of locationManagerDidChangeAuthorization(_:)
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        let status = manager.authorizationStatus
        if (status == .authorizedAlways || status == .authorizedWhenInUse) && pendingStart {
            pendingStart = false
            beginSession()
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations newLocations: [CLLocation]) {
        guard !newLocations.isEmpty else { return }
        if isRunning {
            for loc in newLocations {
                guard loc.horizontalAccuracy > 0, loc.horizontalAccuracy <= maxAcceptableAccuracyMeters else { continue }
                if let last = locations.last {
                    let delta = loc.distance(from: last)
                    guard delta >= minAppendDistanceMeters && delta <= maxJumpMeters else { continue }
                    distanceMeters += delta
                    // Goal: distance-based
                    if !goalReached, let dg = distanceGoalMeters, distanceMeters >= dg {
                        goalReached = true
                        haptic.notificationOccurred(.success)
                    }
                } else {
                    routeCoordinates.append(loc.coordinate)
                }
                // Append raw and smoothed route
                locations.append(loc)
                let smoothed = smoothedCoordinate(for: loc.coordinate)
                routeCoordinates.append(smoothed)
                if distanceMeters >= nextHapticMeters {
                    haptic.notificationOccurred(.success)
                    nextHapticMeters += 1000
                }
                // Elevation gain/loss (only count with decent vertical accuracy)
                let vAcc = loc.verticalAccuracy
                if vAcc >= 0 && vAcc <= 10 { // reasonably accurate
                    if let la = lastAltitude {
                        let deltaAlt = loc.altitude - la
                        if deltaAlt > minElevationDeltaMeters { 
                            elevationGainMeters += deltaAlt 
                        } else if deltaAlt < -minElevationDeltaMeters {
                            elevationLossMeters += abs(deltaAlt)
                        }
                    }
                    lastAltitude = loc.altitude
                }
                // Auto-pause/resume based on speed and motion
                let speed = loc.speed // -1 if invalid
                tryAutoPauseResumeConsiderSpeed(speed, timestamp: loc.timestamp)
            }
        } else {
            // When paused, do not mutate route; still use location speed to attempt auto-resume
            for loc in newLocations {
                guard loc.horizontalAccuracy > 0, loc.horizontalAccuracy <= maxAcceptableAccuracyMeters else { continue }
                tryAutoPauseResumeConsiderSpeed(loc.speed, timestamp: loc.timestamp)
            }
        }
    }

    private func internalAutoPause() {
        guard isRunning else { return }
        autoPaused = true
        isRunning = false
        pauseDate = Date()
        // Keep location updates running so we can detect movement for auto-resume
        // locationManager.stopUpdatingLocation()
        timer?.invalidate()
        timer = nil
    }
    func setActivityKind(_ kind: ActivityKind) {
        activityKind = kind
        configureThresholdsForKind(kind)
    }

    private func configureThresholdsForKind(_ kind: ActivityKind) {
        switch kind {
        case .walk:
            lowSpeedThreshold = 0.5
            resumeSpeedThreshold = 0.6
            minLowSpeedDurationToPause = 5
            minHighSpeedDurationToResume = 3
        case .run:
            lowSpeedThreshold = 1.4
            resumeSpeedThreshold = 2.0
            minLowSpeedDurationToPause = 3
            minHighSpeedDurationToResume = 2
        case .trailRun:
            lowSpeedThreshold = 1.0
            resumeSpeedThreshold = 1.5
            minLowSpeedDurationToPause = 4
            minHighSpeedDurationToResume = 2
        case .hiking:
            lowSpeedThreshold = 0.4
            resumeSpeedThreshold = 0.7
            minLowSpeedDurationToPause = 6
            minHighSpeedDurationToResume = 3
        }
    }

    private func tryAutoPauseResumeConsiderSpeed(_ speed: Double, timestamp: Date) {
        guard autoPauseEnabled, startDate != nil else { return }
        if durationSeconds < minSessionSecondsForAutoPause { return }

        let belowLow = (speed >= 0 && speed < lowSpeedThreshold) || (speed < 0 && motionStationary)
        let aboveHigh = (speed >= resumeSpeedThreshold) || motionWalkingOrRunning

        if manualPaused { lowSpeedStart = nil; highSpeedStart = nil; return }

        if autoPaused {
            if aboveHigh {
                if highSpeedStart == nil { highSpeedStart = timestamp }
                if let hs = highSpeedStart, timestamp.timeIntervalSince(hs) >= minHighSpeedDurationToResume {
                    resume()
                }
            } else {
                highSpeedStart = nil
            }
        } else {
            if belowLow {
                if lowSpeedStart == nil { lowSpeedStart = timestamp }
                if let ls = lowSpeedStart, timestamp.timeIntervalSince(ls) >= minLowSpeedDurationToPause {
                    internalAutoPause()
                }
            } else {
                lowSpeedStart = nil
            }
        }
    }
    private func smoothedCoordinate(for new: CLLocationCoordinate2D) -> CLLocationCoordinate2D {
        if let last = routeCoordinates.last {
            let lat = last.latitude + smoothAlpha * (new.latitude - last.latitude)
            let lon = last.longitude + smoothAlpha * (new.longitude - last.longitude)
            return CLLocationCoordinate2D(latitude: lat, longitude: lon)
        } else {
            return new
        }
    }

    func summary() -> ActivitySummary {
        let samples: [RouteSample] = locations.map { loc in
            RouteSample(latitude: loc.coordinate.latitude,
                        longitude: loc.coordinate.longitude,
                        timestamp: loc.timestamp)
        }
        
        // Calculate averages
        let avgCadence = cadenceSamples.isEmpty ? nil : cadenceSamples.reduce(0, +) / Double(cadenceSamples.count)
        let avgHeartRate = heartRateSamples.isEmpty ? nil : heartRateSamples.reduce(0, +) / Double(heartRateSamples.count)
        
        // Calculate average stride (distance per step)
        let avgStride: Double? = {
            guard totalSteps > 0, distanceMeters > 0 else { return nil }
            return distanceMeters / Double(totalSteps)
        }()
        
        let totalCals = estimateCalories()
        let activeCals = totalCals * 0.85 // Active calories ~85% of total
        
        return ActivitySummary(
            distanceMeters: distanceMeters,
            durationSeconds: durationSeconds,
            route: routeCoordinates,
            routeSamples: samples,
            startDate: startDate ?? Date(),
            endDate: Date(),
            kind: activityKind,
            caloriesKilocalories: totalCals,
            activeCaloriesKilocalories: activeCals,
            stepsCount: (totalSteps > 0 ? totalSteps : nil),
            elevationGainMeters: (elevationGainMeters > 0 ? elevationGainMeters : nil),
            elevationLossMeters: (elevationLossMeters > 0 ? elevationLossMeters : nil),
            avgCadenceSPM: avgCadence,
            avgHeartRateBPM: avgHeartRate,
            avgStrideMeters: avgStride
        )
    }

    private func estimateCalories() -> Double {
        // Simple MET-based estimate; refine later with HealthKit data
        // MET values approximate: walk 3.5, run 9.8, trail run 7.5, hiking 6.0
        let met: Double
        switch activityKind {
        case .walk: met = 3.5
        case .run: met = 9.8
        case .trailRun: met = 7.5
        case .hiking: met = 6.0
        }
        // Assume body mass 70kg if not available; kcal = MET * 3.5 * weight(kg)/200 * minutes
        let weightKg: Double = 70
        let minutes = max(durationSeconds, 0) / 60.0
        let kcal = met * 3.5 * weightKg / 200.0 * minutes
        return max(kcal, 0)
    }

    static func formattedPace(distanceMeters: Double, durationSeconds: Double) -> String {
        guard distanceMeters > 1, durationSeconds > 0 else { return "--" }
        let paceSecPerKm = durationSeconds / (distanceMeters / 1000.0)
        let minutes = Int(paceSecPerKm) / 60
        let seconds = Int(paceSecPerKm) % 60
        return String(format: "%d:%02d min/km", minutes, seconds)
    }

    static func formattedDuration(_ seconds: Double) -> String {
        let s = Int(seconds)
        let h = s / 3600
        let m = (s % 3600) / 60
        let sec = s % 60
        if h > 0 { return String(format: "%d:%02d:%02d", h, m, sec) }
        return String(format: "%02d:%02d", m, sec)
    }

    // Goal progress helpers
    func goalProgressFraction() -> Double {
        if let dg = distanceGoalMeters, dg > 0 {
            return min(max(distanceMeters / dg, 0), 1)
        }
        if let tg = timeGoalSeconds, tg > 0 {
            return min(max(durationSeconds / tg, 0), 1)
        }
        return 0
    }

    func goalProgressText() -> String {
        if let dg = distanceGoalMeters {
            return String(format: "%.2f km of %.2f km", distanceMeters / 1000.0, dg / 1000.0)
        }
        if let tg = timeGoalSeconds {
            return "\(ActivityTrackingViewModel.formattedDuration(durationSeconds)) of \(ActivityTrackingViewModel.formattedDuration(tg))"
        }
        return "No goal"
    }

    func goalRemainingEstimateText() -> String {
        if let dg = distanceGoalMeters {
            let remainingMeters = max(dg - distanceMeters, 0)
            let secPerMeter = distanceMeters > 1 ? durationSeconds / distanceMeters : 0
            let estimatedSeconds = secPerMeter > 0 ? remainingMeters * secPerMeter : 0
            let remainDistStr = String(format: "%.2f km left", remainingMeters / 1000.0)
            let estimateStr = estimatedSeconds > 0 ? " (~\(ActivityTrackingViewModel.formattedDuration(estimatedSeconds)))" : ""
            return remainDistStr + estimateStr
        }
        if let tg = timeGoalSeconds {
            let remainingSeconds = max(tg - durationSeconds, 0)
            let secPerMeter = distanceMeters > 1 ? durationSeconds / distanceMeters : 0
            let estimatedMeters = secPerMeter > 0 ? remainingSeconds / secPerMeter : 0
            let remainTimeStr = "\(ActivityTrackingViewModel.formattedDuration(remainingSeconds)) left"
            let estimateStr = estimatedMeters > 0 ? String(format: " (~%.2f km)", estimatedMeters / 1000.0) : ""
            return remainTimeStr + estimateStr
        }
        return ""
    }

    func goalEstimatedFinishTimeText() -> String {
        guard let dg = distanceGoalMeters else { return "" }
        let remainingMeters = max(dg - distanceMeters, 0)
        let secPerMeter = distanceMeters > 1 ? durationSeconds / distanceMeters : 0
        let estimatedSeconds = secPerMeter > 0 ? remainingMeters * secPerMeter : 0
        guard estimatedSeconds > 0 else { return "" }
        let finish = Date().addingTimeInterval(estimatedSeconds)
        return finish.formatted(date: .omitted, time: .shortened)
    }

    private func startMotionUpdates() {
        guard CMMotionActivityManager.isActivityAvailable() else { return }
        if motionManager == nil { motionManager = CMMotionActivityManager() }
        motionManager?.startActivityUpdates(to: OperationQueue.main) { [weak self] activity in
            guard let self = self, let a = activity else { return }
            self.motionStationary = a.stationary || a.unknown
            self.motionWalkingOrRunning = a.walking || a.running
            self.tryAutoPauseResumeConsiderSpeed(-1, timestamp: Date())
        }
    }

    private func stopMotionUpdates() {
        motionManager?.stopActivityUpdates()
        motionStationary = false
        motionWalkingOrRunning = false
    }

    private func startPedometerUpdates() {
        guard CMPedometer.isCadenceAvailable() || CMPedometer.isStepCountingAvailable() else { return }
        if let start = startDate {
            pedometer.startUpdates(from: start) { [weak self] data, _ in
                guard let self = self, let d = data else { return }
                if let cadence = d.currentCadence?.doubleValue { 
                    let cadenceSPM = cadence * 60.0
                    self.currentCadenceSPM = cadenceSPM
                    // Store sample for averaging
                    self.cadenceSamples.append(cadenceSPM)
                }
                let steps = d.numberOfSteps.intValue
                self.totalSteps = max(steps, 0)
            }
        }
    }

    private func stopPedometerUpdates() {
        pedometer.stopUpdates()
        currentCadenceSPM = nil
    }

    func setTimeGoal(_ seconds: Double?) { timeGoalSeconds = seconds }
    func setDistanceGoal(_ meters: Double?) { distanceGoalMeters = meters }

    // Add in-run marker at current coordinate with optional note and photo
    func addMarker(note: String?, photo: UIImage?) {
        guard let coord = (routeCoordinates.last ?? locations.last?.coordinate) else { return }
        let trimmed = note?.trimmingCharacters(in: .whitespacesAndNewlines)
        let marker = ActivityMarker(
            id: UUID(),
            latitude: coord.latitude,
            longitude: coord.longitude,
            timestamp: Date(),
            note: (trimmed?.isEmpty ?? true) ? nil : trimmed,
            photoPNG: photo?.pngData()
        )
        markers.append(marker)
    }
}

extension ActivitySummary {
    func withChallenge(title: String?, isPublic: Bool?) -> ActivitySummary {
        ActivitySummary(
            distanceMeters: self.distanceMeters,
            durationSeconds: self.durationSeconds,
            route: self.route,
            routeSamples: self.routeSamples,
            startDate: self.startDate,
            endDate: self.endDate,
            kind: self.kind,
            caloriesKilocalories: self.caloriesKilocalories,
            activeCaloriesKilocalories: self.activeCaloriesKilocalories,
            stepsCount: self.stepsCount,
            elevationGainMeters: self.elevationGainMeters,
            elevationLossMeters: self.elevationLossMeters,
            avgCadenceSPM: self.avgCadenceSPM,
            avgHeartRateBPM: self.avgHeartRateBPM,
            avgStrideMeters: self.avgStrideMeters,
            linkedChallengeTitle: title,
            linkedChallengeIsPublic: isPublic
        )
    }
    
    // Computed properties for formatted metrics
    var formattedAvgPace: String {
        guard distanceMeters > 1, durationSeconds > 0 else { return "--" }
        let paceSecPerKm = durationSeconds / (distanceMeters / 1000.0)
        let minutes = Int(paceSecPerKm) / 60
        let seconds = Int(paceSecPerKm) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    
    var formattedAvgSpeed: String {
        guard distanceMeters > 0, durationSeconds > 0 else { return "--" }
        let speedKmh = (distanceMeters / 1000.0) / (durationSeconds / 3600.0)
        return String(format: "%.1f km/h", speedKmh)
    }
    
    var formattedDuration: String {
        let s = Int(durationSeconds)
        let h = s / 3600
        let m = (s % 3600) / 60
        let sec = s % 60
        if h > 0 { return String(format: "%d:%02d:%02d", h, m, sec) }
        return String(format: "%02d:%02d", m, sec)
    }
}