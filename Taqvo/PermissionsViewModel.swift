//
//  PermissionsViewModel.swift
//  Taqvo
//
//  Generated by Assistant on 10/17/25
//

import Foundation
import CoreLocation
import CoreMotion
import HealthKit

final class PermissionsViewModel: NSObject, ObservableObject, CLLocationManagerDelegate {
    @Published var isRequesting: Bool = false
    @Published var locationAuthorizedState: Bool = PermissionsViewModel.locationAuthorized()
    @Published var alwaysAuthorizedState: Bool = PermissionsViewModel.alwaysAuthorized()

    private let locationManager = CLLocationManager()
    private let pedometer = CMPedometer()
    private let healthStore = HKHealthStore()

    override init() {
        super.init()
        locationManager.delegate = self
    }

    // MARK: - Location
    func requestLocationAuthorization() {
        isRequesting = true
        // Request WhenInUse first; upgrade to Always later if needed for background tracking
        locationManager.requestWhenInUseAuthorization()
    }

    func requestAlwaysAuthorization() {
        isRequesting = true
        locationManager.requestAlwaysAuthorization()
    }

    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        isRequesting = false
        // Publish latest states so UI can update immediately
        locationAuthorizedState = PermissionsViewModel.locationAuthorized()
        alwaysAuthorizedState = PermissionsViewModel.alwaysAuthorized()
    }

    // iOS < 14 and certain flows still call this older delegate
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        isRequesting = false
        locationAuthorizedState = (status == .authorizedWhenInUse || status == .authorizedAlways)
        alwaysAuthorizedState = (status == .authorizedAlways)
    }

    static func locationAuthorized() -> Bool {
        let status: CLAuthorizationStatus = CLLocationManager().authorizationStatus
        return status == .authorizedWhenInUse || status == .authorizedAlways
    }

    static func alwaysAuthorized() -> Bool {
        CLLocationManager().authorizationStatus == .authorizedAlways
    }
    // MARK: - Motion
    func requestMotionAuthorization(completion: @escaping (Bool) -> Void) {
        isRequesting = true
        // CMPedometer provides authorization status for Motion & Fitness
        if CMPedometer.isStepCountingAvailable() {
            let status = CMPedometer.authorizationStatus()
            if status == .notDetermined {
                // Start a temporary query to trigger permission prompt
                pedometer.queryPedometerData(from: Date(), to: Date()) { _, _ in
                    DispatchQueue.main.async {
                        self.isRequesting = false
                        completion(PermissionsViewModel.motionAuthorized())
                    }
                }
            } else {
                isRequesting = false
                completion(PermissionsViewModel.motionAuthorized())
            }
        } else {
            isRequesting = false
            completion(false)
        }
    }

    static func motionAuthorized() -> Bool {
        let status = CMPedometer.authorizationStatus()
        return status == .authorized
    }

    // MARK: - HealthKit (Optional)
    static func healthAuthorized() -> Bool {
        #if targetEnvironment(simulator)
        return false
        #endif
        guard HKHealthStore.isHealthDataAvailable() else { return false }
        let store = HKHealthStore()
        // Treat Health as enabled if workout sharing is authorized
        let workoutStatus = store.authorizationStatus(for: HKObjectType.workoutType())
        if workoutStatus == .sharingAuthorized { return true }
        // Attempt query for steps type to warm HealthKit, though authorizationStatus(for:) reports sharing only
        if let stepsType = HKObjectType.quantityType(forIdentifier: .stepCount) {
            _ = store.authorizationStatus(for: stepsType)
        }
        return false
    }

    func requestHealthAuthorization(completion: @escaping (Bool) -> Void) {
        #if targetEnvironment(simulator)
        // HealthKit is not available on the iOS Simulator
        completion(false)
        return
        #endif
        guard HKHealthStore.isHealthDataAvailable() else {
            completion(false)
            return
        }
        let readTypes: Set<HKObjectType> = [
            HKObjectType.quantityType(forIdentifier: .stepCount)!,
            HKObjectType.workoutType()
        ]
        let shareTypes: Set<HKSampleType> = [
            HKObjectType.workoutType()
        ]
        healthStore.requestAuthorization(toShare: shareTypes, read: readTypes) { success, _ in
            DispatchQueue.main.async {
                // Consider authorized if workout sharing is granted
                let granted = HKHealthStore().authorizationStatus(for: HKObjectType.workoutType()) == .sharingAuthorized
                completion(success && granted)
            }
        }
    }
}