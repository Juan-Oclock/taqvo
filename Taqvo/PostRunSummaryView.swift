//
//  PostRunSummaryView.swift
//  Taqvo
//
//  Generated by Assistant on 10/17/25
//

import SwiftUI
import MapKit
import PhotosUI
import HealthKit

struct PostRunSummaryView: View {
    let summary: ActivitySummary
    @State private var snapshot: UIImage?
    @EnvironmentObject private var store: ActivityStore
    @Environment(\.dismiss) private var dismiss
    @State private var note: String = ""
    @State private var selectedPhotoItem: PhotosPickerItem?
    @State private var selectedPhoto: UIImage?
    @StateObject private var health = HealthSyncService()
    @State private var saveToHealth: Bool = UserDefaults.standard.bool(forKey: "healthSyncEnabled")
    @State private var healthSaveMessage: String?
    @State private var stepsCount: Int?
    @State private var cadenceSPM: Double?
    @State private var elevationGainMeters: Double?
    @State private var activityTitle: String = ""
    @State private var selectedVisibility: PostVisibility = .privateOnly

    var body: some View {
        ZStack {
            Color.taqvoBackgroundDark.ignoresSafeArea()
            
            ScrollView {
                LazyVStack(spacing: 20) {
                    // Map Section
                    mapSection
                    
                    // Stats Grid
                    statsSection
                    
                    // Input Fields
                    inputSection
                    
                    // Privacy
                    privacySection
                    
                    // Photo Picker
                    photoPickerButton
                    
                    // Health Toggle
                    healthSection
                    
                    // Action Buttons
                    actionButtons
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 20)
            }
        }
        .navigationTitle("Activity Summary")
        .navigationBarTitleDisplayMode(.inline)
        .onAppear { generateSnapshot() }
        .task { await loadHealthData() }
        .onChange(of: selectedPhotoItem) { _, newItem in
            Task { await loadPhoto(newItem) }
        }
        .onChange(of: saveToHealth) { _, newVal in
            UserDefaults.standard.set(newVal, forKey: "healthSyncEnabled")
        }
    }
    
    // MARK: - View Components
    
    private var mapSection: some View {
        Group {
            if let img = snapshot {
                Image(uiImage: img)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(height: 240)
                    .clipped()
                    .cornerRadius(16)
            } else {
                Rectangle()
                    .fill(Color.black.opacity(0.2))
                    .frame(height: 240)
                    .overlay(
                        VStack(spacing: 8) {
                            ProgressView().tint(.taqvoCTA)
                            Text("Generating map…")
                                .font(.system(size: 14))
                                .foregroundColor(.taqvoAccentText)
                        }
                    )
                    .cornerRadius(16)
            }
            
            if let photo = selectedPhoto {
                Image(uiImage: photo)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(height: 240)
                    .clipped()
                    .cornerRadius(16)
            }
        }
    }
    
    private var statsSection: some View {
        VStack(spacing: 12) {
            HStack(spacing: 12) {
                metricCard(icon: "figure.\(summary.kind.rawValue)", label: "Type", value: summary.kind.rawValue.capitalized)
                metricCard(icon: "location.fill", label: "Distance", value: String(format: "%.2f km", summary.distanceMeters/1000.0))
                metricCard(icon: "clock.fill", label: "Duration", value: ActivityTrackingViewModel.formattedDuration(summary.durationSeconds))
            }
            
            HStack(spacing: 12) {
                metricCard(icon: "speedometer", label: "Pace", value: ActivityTrackingViewModel.formattedPace(distanceMeters: summary.distanceMeters, durationSeconds: summary.durationSeconds))
                metricCard(icon: "flame.fill", label: "Calories", value: String(format: "%.0f kcal", summary.caloriesKilocalories))
            }
            
            HStack(spacing: 12) {
                metricCard(icon: "figure.walk", label: "Cadence", value: cadenceSPM.map { String(format: "%.0f spm", $0) } ?? "—")
                metricCard(icon: "shoeprints.fill", label: "Steps", value: stepsCount.map { String($0) } ?? "—")
                metricCard(icon: "mountain.2.fill", label: "Elevation", value: elevationGainMeters.map { String(format: "%.0f m", $0) } ?? "—")
            }
        }
    }
    
    private var inputSection: some View {
        VStack(spacing: 0) {
            TextField("Title (optional)", text: $activityTitle)
                .font(.system(size: 17))
                .foregroundColor(.taqvoTextDark)
                .padding(16)
                .background(Color.black.opacity(0.2))
            
            Divider().background(Color.gray.opacity(0.3))
            
            TextField("Add a note", text: $note, axis: .vertical)
                .font(.system(size: 17))
                .foregroundColor(.taqvoTextDark)
                .padding(16)
                .background(Color.black.opacity(0.2))
                .lineLimit(3...6)
        }
        .cornerRadius(12)
    }
    
    private var privacySection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("PRIVACY")
                .font(.system(size: 13, weight: .semibold))
                .foregroundColor(.taqvoAccentText)
            
            Picker("Privacy", selection: $selectedVisibility) {
                ForEach(PostVisibility.allCases, id: \.self) { visibility in
                    HStack {
                        Image(systemName: visibility.iconName)
                        Text(visibility.displayName)
                    }
                    .tag(visibility)
                }
            }
            .pickerStyle(.segmented)
            
            Text(selectedVisibility.description)
                .font(.system(size: 12))
                .foregroundColor(.taqvoAccentText)
        }
    }
    
    private var photoPickerButton: some View {
        PhotosPicker(selection: $selectedPhotoItem, matching: .images, photoLibrary: .shared()) {
            HStack(spacing: 8) {
                Image(systemName: "photo")
                    .font(.system(size: 18))
                Text(selectedPhoto == nil ? "Add a photo" : "Change photo")
                    .font(.system(size: 16, weight: .medium))
            }
            .foregroundColor(.taqvoTextDark)
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(Color.black.opacity(0.2))
            .cornerRadius(12)
        }
    }
    
    private var healthSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Toggle(isOn: $saveToHealth) {
                HStack(spacing: 8) {
                    Image(systemName: "heart.fill")
                        .foregroundColor(.red)
                        .font(.system(size: 18))
                    Text("Save to Apple Health")
                        .font(.system(size: 16))
                        .foregroundColor(.taqvoTextDark)
                }
            }
            .disabled(!health.authorized)
            .tint(.taqvoCTA)
            .padding(16)
            .background(Color.black.opacity(0.2))
            .cornerRadius(12)
            
            if !health.authorized {
                Text("Enable Health access in Settings to save workouts.")
                    .font(.system(size: 12))
                    .foregroundColor(.taqvoAccentText)
            }
            if let msg = healthSaveMessage, !msg.isEmpty {
                Text(msg)
                    .font(.system(size: 12))
                    .foregroundColor(.taqvoCTA)
            }
        }
    }
    
    private var actionButtons: some View {
        VStack(spacing: 12) {
            Button {
                Task { await handleShareTap() }
            } label: {
                HStack(spacing: 8) {
                    Image(systemName: "paperplane.fill")
                        .font(.system(size: 18))
                    Text("Share to Feed")
                        .font(.system(size: 17, weight: .semibold))
                }
                .foregroundColor(.black)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 18)
                .background(Color.taqvoCTA)
                .cornerRadius(14)
            }
            
            ShareLink(item: summaryShareImageURL()) {
                HStack(spacing: 8) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.system(size: 18))
                    Text("Share Image")
                        .font(.system(size: 17, weight: .semibold))
                }
                .foregroundColor(.taqvoTextDark)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 18)
                .background(Color.black.opacity(0.2))
                .cornerRadius(14)
            }
        }
    }
    
    // MARK: - Helper Functions
    
    private func metricCard(icon: String, label: String, value: String) -> some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.system(size: 18))
                .foregroundColor(.taqvoCTA)
            
            Text(value)
                .font(.system(size: 20, weight: .bold))
                .foregroundColor(.taqvoTextDark)
                .monospacedDigit()
                .lineLimit(1)
                .minimumScaleFactor(0.8)
            
            Text(label)
                .font(.system(size: 11))
                .foregroundColor(.taqvoAccentText)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 16)
        .background(Color.black.opacity(0.2))
        .cornerRadius(12)
    }
    
    private func loadHealthData() async {
        let ok = await health.ensureAuthorization()
        if ok && UserDefaults.standard.object(forKey: "healthSyncEnabled") == nil {
            saveToHealth = true
            UserDefaults.standard.set(true, forKey: "healthSyncEnabled")
        }
        
        if ok {
            if let steps = await health.stepCount(start: summary.startDate, end: summary.endDate) {
                stepsCount = steps
                if cadenceSPM == nil {
                    let minutes = max(summary.durationSeconds / 60.0, 0.001)
                    cadenceSPM = Double(steps) / minutes
                }
            }
            if let cadence = await health.averageCadenceSPM(start: summary.startDate, end: summary.endDate) {
                cadenceSPM = cadence
            }
            if let elev = await health.elevationGainMeters(start: summary.startDate, end: summary.endDate) {
                elevationGainMeters = elev
            }
        }
    }
    
    private func loadPhoto(_ item: PhotosPickerItem?) async {
        guard let item = item else { return }
        do {
            if let data: Data = try await item.loadTransferable(type: Data.self),
               let img = UIImage(data: data) {
                await MainActor.run { selectedPhoto = img }
            }
        } catch {
            // Silently ignore photo load errors
        }
    }

    private func generateSnapshot() {
        guard summary.route.count > 0 else { return }
        let polyline = MKPolyline(coordinates: summary.route, count: summary.route.count)
        let rect = polyline.boundingMapRect
        let region = MKCoordinateRegion(rect)

        let options = MKMapSnapshotter.Options()
        options.region = region
        options.size = CGSize(width: 600, height: 300)
        options.scale = UIScreen.main.scale
        options.showsBuildings = true
        options.mapType = .standard

        let snapshotter = MKMapSnapshotter(options: options)
        snapshotter.start { result, error in
            guard let snapshot = result else { return }
            let image = snapshot.image
            UIGraphicsBeginImageContextWithOptions(image.size, true, image.scale)
            image.draw(at: .zero)

            let path = UIBezierPath()
            for (i, coord) in summary.route.enumerated() {
                let point = snapshot.point(for: coord)
                if i == 0 { path.move(to: point) } else { path.addLine(to: point) }
            }
            UIColor.systemGreen.setStroke()
            path.lineWidth = 4
            path.stroke()

            let final = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            DispatchQueue.main.async { self.snapshot = final }
        }
    }

    // Compose a summary share image (map/photo + stats overlay) and write PNG to a temp URL
    private func summaryShareImageURL() -> URL {
        let verb: String
        switch summary.kind {
        case .walk: verb = "Walked"
        case .run: verb = "Ran"
        case .trailRun: verb = "Trail Ran"
        case .hiking: verb = "Hiked"
        }

        let bgImage: UIImage? = snapshot ?? selectedPhoto
        let shareView = ZStack {
            if let img = bgImage {
                Image(uiImage: img).resizable().aspectRatio(contentMode: .fill)
            } else {
                LinearGradient(colors: [.black, .gray.opacity(0.6)], startPoint: .topLeading, endPoint: .bottomTrailing)
            }
            VStack(alignment: .leading, spacing: 6) {
                let header: String = {
                    let t = activityTitle.trimmingCharacters(in: .whitespacesAndNewlines)
                    if !t.isEmpty { return t }
                    return verb + " " + String(format: "%.2f km", summary.distanceMeters/1000.0)
                }()
                Text(header)
                    .font(.headline)
                    .foregroundColor(.white)
                    .shadow(color: .black.opacity(0.6), radius: 2)
                HStack(spacing: 12) {
                    Text(ActivityTrackingViewModel.formattedDuration(summary.durationSeconds))
                    Text(ActivityTrackingViewModel.formattedPace(distanceMeters: summary.distanceMeters, durationSeconds: summary.durationSeconds))
                    Text(String(format: "%.0f kcal", summary.caloriesKilocalories))
                }
                .font(.subheadline)
                .foregroundColor(.white)
                .shadow(color: .black.opacity(0.6), radius: 2)
                Text(summary.endDate.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.9))
                    .shadow(color: .black.opacity(0.6), radius: 2)
                Spacer()
                HStack {
                    Image(systemName: "figure.run")
                    Text("Taqvo")
                }
                .font(.caption)
                .foregroundColor(.white.opacity(0.9))
                .padding(.top, 8)
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .frame(width: 800, height: 450)

        let renderer = ImageRenderer(content: shareView)
        renderer.scale = 2
        let url = FileManager.default.temporaryDirectory.appendingPathComponent("taqvo-summary-\(Int(summary.endDate.timeIntervalSince1970)).png")
        if let uiImg = renderer.uiImage, let data = uiImg.pngData() {
            try? data.write(to: url)
        } else {
            // Guaranteed PNG fallback
            let size = CGSize(width: 800, height: 450)
            UIGraphicsBeginImageContextWithOptions(size, true, 2)
            UIColor.black.setFill()
            UIBezierPath(rect: CGRect(origin: .zero, size: size)).fill()
            let fallback = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            if let data = fallback?.pngData() { try? data.write(to: url) }
        }
        return url
    }

    @MainActor
    private func handleShareTap() async {
        if saveToHealth && health.authorized {
            let ok = await health.save(summary: summary)
            healthSaveMessage = ok ? "Saved to Health" : "Health save failed"
        }
        // Attempt to fetch average heart rate for intensity if authorized
        let avgHR = health.authorized ? await health.averageHeartRateBPM(start: summary.startDate, end: summary.endDate) : nil
        let trimmedTitle = activityTitle.trimmingCharacters(in: .whitespacesAndNewlines)
        let passedTitle = trimmedTitle.isEmpty ? nil : trimmedTitle
        store.add(summary: summary,
                  snapshot: snapshot,
                  note: note.isEmpty ? nil : note,
                  photo: selectedPhoto,
                  avgHeartRateBPM: avgHR,
                  title: passedTitle,
                  visibility: selectedVisibility)
        dismiss()
    }
}

#Preview {
    PostRunSummaryView(summary: ActivitySummary(distanceMeters: 1234,
                                                durationSeconds: 456,
                                                route: [],
                                                routeSamples: [],
                                                startDate: Date(),
                                                endDate: Date(),
                                                kind: .run,
                                                caloriesKilocalories: 123))
}

// HealthKit sync service
@MainActor
final class HealthSyncService: ObservableObject {
    @Published private(set) var authorized: Bool = false
    private let store = HKHealthStore()

    func ensureAuthorization() async -> Bool {
        guard HKHealthStore.isHealthDataAvailable() else { return false }
        var share: Set<HKSampleType> = [HKObjectType.workoutType()]
        var read: Set<HKObjectType> = [HKObjectType.workoutType()]
        if let distWR = HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning) {
            share.insert(distWR)
            read.insert(distWR)
        }
        if let distCyc = HKQuantityType.quantityType(forIdentifier: .distanceCycling) {
            share.insert(distCyc)
            read.insert(distCyc)
        }
        if let energy = HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned) {
            share.insert(energy)
            read.insert(energy)
        }
        // Read heart rate for intensity (no sharing needed)
        if let hr = HKQuantityType.quantityType(forIdentifier: .heartRate) {
            read.insert(hr)
        }
        // Steps and floors
        if let steps = HKQuantityType.quantityType(forIdentifier: .stepCount) {
            read.insert(steps)
        }
        if let floorsUp = HKQuantityType.quantityType(forIdentifier: .flightsClimbed) {
            read.insert(floorsUp)
        }
        // Removed cadence quantity types to support broader SDKs; cadence will be derived from steps/time
        share.insert(HKSeriesType.workoutRoute())
        read.insert(HKSeriesType.workoutRoute())

        let success = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            store.requestAuthorization(toShare: share, read: read) { ok, _ in
                cont.resume(returning: ok)
            }
        }
        authorized = success
        return success
    }

    func save(summary: ActivitySummary) async -> Bool {
        if !authorized {
            let ok = await ensureAuthorization()
            guard ok else { return false }
        }

        // Configure type based on summary.kind
        let config = HKWorkoutConfiguration()
        switch summary.kind {
        case .walk: config.activityType = .walking
        case .run, .trailRun: config.activityType = .running
        case .hiking: config.activityType = .hiking
        }

        let builder = HKWorkoutBuilder(healthStore: store, configuration: config, device: nil)

        let began = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            builder.beginCollection(withStart: summary.startDate) { ok, _ in cont.resume(returning: ok) }
        }
        guard began else { return false }

        // Distance
        let distanceQty = HKQuantity(unit: HKUnit.meter(), doubleValue: summary.distanceMeters)
        let distanceType: HKQuantityTypeIdentifier = .distanceWalkingRunning
        if let distType = HKQuantityType.quantityType(forIdentifier: distanceType) {
            let sample = HKQuantitySample(type: distType, quantity: distanceQty, start: summary.startDate, end: summary.endDate)
            await withCheckedContinuation { (cont: CheckedContinuation<Void, Never>) in
                builder.add([sample]) { _, _ in
                    cont.resume()
                }
            }
        }

        // Active energy
        if let energyType = HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned) {
            let energyQty = HKQuantity(unit: HKUnit.kilocalorie(), doubleValue: summary.caloriesKilocalories)
            let sample = HKQuantitySample(type: energyType, quantity: energyQty, start: summary.startDate, end: summary.endDate)
            await withCheckedContinuation { (cont: CheckedContinuation<Void, Never>) in
                builder.add([sample]) { _, _ in
                    cont.resume()
                }
            }
        }

        // Route
        let routeBuilder = HKWorkoutRouteBuilder(healthStore: store, device: nil)
        let locs = HealthSyncService.locations(from: summary.route, start: summary.startDate, end: summary.endDate)
        do {
            try await routeBuilder.insertRouteData(locs)
        } catch {
            // intentionally ignore route errors
        }

        let finished = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            builder.endCollection(withEnd: summary.endDate) { ok, _ in cont.resume(returning: ok) }
        }
        guard finished else { return false }

        let saved = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            builder.finishWorkout { workout, error in
                cont.resume(returning: workout != nil)
            }
        }

        return saved
    }

    // Compute average heart rate (bpm) for a time range
    func averageHeartRateBPM(start: Date, end: Date) async -> Double? {
        guard authorized, let type = HKQuantityType.quantityType(forIdentifier: .heartRate) else { return nil }
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<Double?, Never>) in
            let q = HKSampleQuery(sampleType: type, predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: nil) { _, samples, _ in
                guard let samples = samples as? [HKQuantitySample], !samples.isEmpty else {
                    cont.resume(returning: nil)
                    return
                }
                let unit = HKUnit.count().unitDivided(by: HKUnit.minute())
                let total = samples.reduce(0.0) { $0 + $1.quantity.doubleValue(for: unit) }
                cont.resume(returning: total / Double(samples.count))
            }
            self.store.execute(q)
        }
    }

    // Steps count for a time range
    func stepCount(start: Date, end: Date) async -> Int? {
        guard authorized, let type = HKQuantityType.quantityType(forIdentifier: .stepCount) else { return nil }
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<Int?, Never>) in
            let q = HKStatisticsQuery(quantityType: type, quantitySamplePredicate: predicate, options: .cumulativeSum) { _, stats, _ in
                let count = stats?.sumQuantity()?.doubleValue(for: HKUnit.count())
                cont.resume(returning: count.map { Int($0) })
            }
            self.store.execute(q)
        }
    }

    // Average cadence (steps per minute) for a time range, derived from steps/duration
    func averageCadenceSPM(start: Date, end: Date) async -> Double? {
        guard authorized else { return nil }
        if let steps = await stepCount(start: start, end: end) {
            let minutes = max(end.timeIntervalSince(start) / 60.0, 0.001)
            return Double(steps) / minutes
        }
        return nil
    }

    // Elevation gain estimate using flights climbed (approx 3.0 m per floor)
    func elevationGainMeters(start: Date, end: Date) async -> Double? {
        guard authorized, let type = HKQuantityType.quantityType(forIdentifier: .flightsClimbed) else { return nil }
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<Double?, Never>) in
            let q = HKStatisticsQuery(quantityType: type, quantitySamplePredicate: predicate, options: .cumulativeSum) { _, stats, _ in
                if let floors = stats?.sumQuantity()?.doubleValue(for: HKUnit.count()) {
                    cont.resume(returning: floors * 3.0)
                } else { cont.resume(returning: nil) }
            }
            self.store.execute(q)
        }
    }

    // Import past workouts from Apple Health and convert to ActivitySummary objects
    func importWorkouts(daysBack: Int) async -> [ActivitySummary] {
        if !authorized {
            let ok = await ensureAuthorization()
            guard ok else { return [] }
        }
        let end = Date()
        let start = Calendar.current.date(byAdding: .day, value: -daysBack, to: end) ?? end.addingTimeInterval(-Double(daysBack) * 86400)
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<[ActivitySummary], Never>) in
            let q = HKSampleQuery(sampleType: HKObjectType.workoutType(), predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: nil) { _, samples, _ in
                guard let workouts = samples as? [HKWorkout] else {
                    cont.resume(returning: [])
                    return
                }
                Task {
                    let results = await withTaskGroup(of: ActivitySummary?.self) { group in
                        for w in workouts {
                            group.addTask {
                                let kind: ActivityKind
                                switch w.workoutActivityType {
                                case .walking: kind = .walk
                                case .running: kind = .run
                                case .hiking: kind = .hiking
                                default: kind = .run
                                }
                                let meters = w.totalDistance?.doubleValue(for: HKUnit.meter()) ?? 0
                                let kcal: Double
                                if #available(iOS 18.0, *) {
                                    if let type = HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned) {
                                        let stats = w.statistics(for: type)
                                        kcal = stats?.sumQuantity()?.doubleValue(for: HKUnit.kilocalorie()) ?? 0
                                    } else {
                                        kcal = 0
                                    }
                                } else {
                                    kcal = w.totalEnergyBurned?.doubleValue(for: HKUnit.kilocalorie()) ?? 0
                                }
                                let (coords, samples) = await self.routeForWorkout(w)
                                return ActivitySummary(distanceMeters: meters,
                                                      durationSeconds: w.duration,
                                                      route: coords,
                                                      routeSamples: samples,
                                                      startDate: w.startDate,
                                                      endDate: w.endDate,
                                                      kind: kind,
                                                      caloriesKilocalories: kcal)
                            }
                        }
                        var collected: [ActivitySummary] = []
                        for await item in group {
                            if let sum = item { collected.append(sum) }
                        }
                        return collected
                    }
                    cont.resume(returning: results)
                }
            }
            self.store.execute(q)
        }
    }

    private func routeForWorkout(_ workout: HKWorkout) async -> ([CLLocationCoordinate2D], [RouteSample]) {
        guard authorized else { return ([], []) }
        let predicate = HKQuery.predicateForObjects(from: workout)
        return await withCheckedContinuation { (cont: CheckedContinuation<([CLLocationCoordinate2D], [RouteSample]), Never>) in
            let q = HKSampleQuery(sampleType: HKSeriesType.workoutRoute(), predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: nil) { _, samples, _ in
                guard let routes = samples as? [HKWorkoutRoute], !routes.isEmpty else {
                    cont.resume(returning: ([], []))
                    return
                }
                var allLocations: [CLLocation] = []
                let group = DispatchGroup()
                for route in routes {
                    group.enter()
                    var routeLocations: [CLLocation] = []
                    let rq = HKWorkoutRouteQuery(route: route) { _, locs, done, _ in
                        if let locs = locs { routeLocations.append(contentsOf: locs) }
                        if done {
                            allLocations.append(contentsOf: routeLocations)
                            group.leave()
                        }
                    }
                    self.store.execute(rq)
                }
                group.notify(queue: .main) {
                    let coords = allLocations.map { $0.coordinate }
                    let samples = allLocations.map { RouteSample(latitude: $0.coordinate.latitude, longitude: $0.coordinate.longitude, timestamp: $0.timestamp) }
                    cont.resume(returning: (coords, samples))
                }
            }
            self.store.execute(q)
        }
    }

    private static func locations(from coords: [CLLocationCoordinate2D], start: Date, end: Date) -> [CLLocation] {
        guard !coords.isEmpty else { return [] }
        let per = max(1, Int((end.timeIntervalSince(start)) / Double(max(coords.count, 1))))
        var result: [CLLocation] = []
        var t = start
        for c in coords {
            result.append(CLLocation(coordinate: c, altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10, timestamp: t))
            t = t.addingTimeInterval(TimeInterval(per))
        }
        return result
    }
}