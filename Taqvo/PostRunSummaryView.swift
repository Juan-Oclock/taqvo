//
//  PostRunSummaryView.swift
//  Taqvo
//
//  Generated by Assistant on 10/17/25
//

import SwiftUI
import MapKit
import PhotosUI
import HealthKit

struct PostRunSummaryView: View {
    let summary: ActivitySummary
    @State private var snapshot: UIImage?
    @EnvironmentObject private var store: ActivityStore
    @Environment(\.dismiss) private var dismiss
    @State private var note: String = ""
    @State private var selectedPhotoItem: PhotosPickerItem?
    @State private var selectedPhoto: UIImage?
    @StateObject private var health = HealthSyncService()
    @State private var saveToHealth: Bool = UserDefaults.standard.bool(forKey: "healthSyncEnabled")
    @State private var healthSaveMessage: String?
    // Added metrics
    @State private var stepsCount: Int?
    @State private var cadenceSPM: Double?
    @State private var elevationGainMeters: Double?
    // Optional custom title for the activity
    @State private var activityTitle: String = ""

    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                if let img = snapshot {
                    Image(uiImage: img)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .cornerRadius(12)
                } else {
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 220)
                        .overlay(Text("Generating map…").foregroundColor(.taqvoAccentText))
                        .cornerRadius(12)
                }

                if let photo = selectedPhoto {
                    Image(uiImage: photo)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .cornerRadius(12)
                }

                // Metrics
                HStack(spacing: 16) {
                    metric("Type", summary.kind.rawValue.capitalized)
                    metric("Distance", String(format: "%.2f km", summary.distanceMeters/1000.0))
                    metric("Duration", ActivityTrackingViewModel.formattedDuration(summary.durationSeconds))
                }
                HStack(spacing: 16) {
                    metric("Avg Pace", ActivityTrackingViewModel.formattedPace(distanceMeters: summary.distanceMeters, durationSeconds: summary.durationSeconds))
                    metric("Calories", String(format: "%.0f kcal", summary.caloriesKilocalories))
                }
                // New metrics row
                HStack(spacing: 16) {
                    let cadenceText: String = {
                        if let spm = cadenceSPM { return String(format: "%.0f spm", spm) }
                        else { return "—" }
                    }()
                    let stepsText: String = {
                        if let steps = stepsCount { return String(steps) } else { return "—" }
                    }()
                    let elevationText: String = {
                        if let elev = elevationGainMeters { return String(format: "%.0f m", elev) } else { return "—" }
                    }()
                    metric("Cadence", cadenceText)
                    metric("Steps", stepsText)
                    metric("Elevation", elevationText)
                }

                // Note input
                VStack(alignment: .leading, spacing: 8) {
                    Text("Title (optional)")
                        .font(.caption)
                        .foregroundColor(.taqvoAccentText)
                    TextField("e.g., Morning Run", text: $activityTitle)
                        .textFieldStyle(.roundedBorder)
                }

                VStack(alignment: .leading, spacing: 8) {
                    Text("Add a note")
                        .font(.caption)
                        .foregroundColor(.taqvoAccentText)
                    TextField("How did it feel?", text: $note, axis: .vertical)
                        .textFieldStyle(.roundedBorder)
                        .lineLimit(3...6)
                }

                // Photo picker
                PhotosPicker(selection: $selectedPhotoItem, matching: .images, photoLibrary: .shared()) {
                    HStack {
                        Image(systemName: "photo")
                        Text(selectedPhoto == nil ? "Add a photo" : "Change photo")
                    }
                    .font(.headline)
                    .foregroundColor(.taqvoTextLight)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.white.opacity(0.85))
                    .cornerRadius(16)
                }
                .onChange(of: selectedPhotoItem) { _, newItem in
                    Task {
                        if let item = newItem {
                            do {
                                if let data: Data = try await item.loadTransferable(type: Data.self) {
                                    if let img = UIImage(data: data) {
                                        await MainActor.run { selectedPhoto = img }
                                    }
                                }
                            } catch {
                                // silently ignore photo load errors
                            }
                        }
                    }
                }

                // Save to Apple Health toggle
                VStack(alignment: .leading, spacing: 8) {
                    Toggle(isOn: $saveToHealth) {
                        HStack {
                            Image(systemName: "heart.fill").foregroundColor(.red)
                            Text("Save to Apple Health")
                        }
                    }
                    .disabled(!health.authorized)
                    .tint(.taqvoCTA)

                    if !health.authorized {
                        Text("Enable Health access in Settings to save workouts.")
                            .font(.caption)
                            .foregroundColor(.taqvoAccentText)
                    }
                    if let msg = healthSaveMessage, !msg.isEmpty {
                        Text(msg)
                            .font(.caption)
                            .foregroundColor(.taqvoAccentText)
                    }
                }
                .onChange(of: saveToHealth) { _, newVal in
                    UserDefaults.standard.set(newVal, forKey: "healthSyncEnabled")
                }

                HStack(spacing: 12) {
                    ShareLink(item: summaryShareImageURL()) {
                        HStack {
                            Image(systemName: "square.and.arrow.up")
                            Text("Share Image")
                        }
                        .font(.headline)
                        .foregroundColor(.taqvoTextLight)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.white.opacity(0.85))
                        .cornerRadius(16)
                    }

                    Button {
                        Task {
                            await handleShareTap()
                        }
                    } label: {
                        Text("Share to Feed")
                            .font(.headline)
                            .foregroundColor(.taqvoTextLight)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.taqvoCTA)
                            .cornerRadius(16)
                    }
                }
            }
            .padding()
        }
        .onAppear {
            generateSnapshot()
        }
        .task {
            let ok = await health.ensureAuthorization()
            if ok && UserDefaults.standard.object(forKey: "healthSyncEnabled") == nil {
                saveToHealth = true
                UserDefaults.standard.set(true, forKey: "healthSyncEnabled")
            }
            // Fetch metrics when possible
            if ok {
                if let steps = await health.stepCount(start: summary.startDate, end: summary.endDate) {
                    stepsCount = steps
                    if cadenceSPM == nil {
                        let minutes = max(summary.durationSeconds / 60.0, 0.001)
                        cadenceSPM = Double(steps) / minutes
                    }
                }
                if let cadence = await health.averageCadenceSPM(start: summary.startDate, end: summary.endDate) {
                    cadenceSPM = cadence
                }
                if let elev = await health.elevationGainMeters(start: summary.startDate, end: summary.endDate) {
                    elevationGainMeters = elev
                }
            }
        }
        .navigationTitle("Summary")
        .background(Color.taqvoBackgroundDark)
    }

    private func metric(_ title: String, _ value: String) -> some View {
        VStack {
            Text(title).foregroundColor(.taqvoAccentText).font(.caption)
            Text(value).foregroundColor(.taqvoTextDark).font(.title3).monospacedDigit()
        }
        .frame(maxWidth: .infinity)
        .padding(8)
        .background(Color.black.opacity(0.2))
        .cornerRadius(12)
    }

    private func generateSnapshot() {
        guard summary.route.count > 0 else { return }
        let polyline = MKPolyline(coordinates: summary.route, count: summary.route.count)
        let rect = polyline.boundingMapRect
        let region = MKCoordinateRegion(rect)

        let options = MKMapSnapshotter.Options()
        options.region = region
        options.size = CGSize(width: 600, height: 300)
        options.scale = UIScreen.main.scale
        options.showsBuildings = true
        options.mapType = .standard

        let snapshotter = MKMapSnapshotter(options: options)
        snapshotter.start { result, error in
            guard let snapshot = result else { return }
            let image = snapshot.image
            UIGraphicsBeginImageContextWithOptions(image.size, true, image.scale)
            image.draw(at: .zero)

            let path = UIBezierPath()
            for (i, coord) in summary.route.enumerated() {
                let point = snapshot.point(for: coord)
                if i == 0 { path.move(to: point) } else { path.addLine(to: point) }
            }
            UIColor.systemGreen.setStroke()
            path.lineWidth = 4
            path.stroke()

            let final = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            DispatchQueue.main.async { self.snapshot = final }
        }
    }

    // Compose a summary share image (map/photo + stats overlay) and write PNG to a temp URL
    private func summaryShareImageURL() -> URL {
        let verb: String
        switch summary.kind {
        case .walk: verb = "Walked"
        case .jog: verb = "Jogged"
        case .run: verb = "Ran"
        case .ride: verb = "Rode"
        }

        let bgImage: UIImage? = snapshot ?? selectedPhoto
        let shareView = ZStack {
            if let img = bgImage {
                Image(uiImage: img).resizable().aspectRatio(contentMode: .fill)
            } else {
                LinearGradient(colors: [.black, .gray.opacity(0.6)], startPoint: .topLeading, endPoint: .bottomTrailing)
            }
            VStack(alignment: .leading, spacing: 6) {
                let header: String = {
                    let t = activityTitle.trimmingCharacters(in: .whitespacesAndNewlines)
                    if !t.isEmpty { return t }
                    return verb + " " + String(format: "%.2f km", summary.distanceMeters/1000.0)
                }()
                Text(header)
                    .font(.headline)
                    .foregroundColor(.white)
                    .shadow(color: .black.opacity(0.6), radius: 2)
                HStack(spacing: 12) {
                    Text(ActivityTrackingViewModel.formattedDuration(summary.durationSeconds))
                    Text(ActivityTrackingViewModel.formattedPace(distanceMeters: summary.distanceMeters, durationSeconds: summary.durationSeconds))
                    Text(String(format: "%.0f kcal", summary.caloriesKilocalories))
                }
                .font(.subheadline)
                .foregroundColor(.white)
                .shadow(color: .black.opacity(0.6), radius: 2)
                Text(summary.endDate.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.9))
                    .shadow(color: .black.opacity(0.6), radius: 2)
                Spacer()
                HStack {
                    Image(systemName: "figure.run")
                    Text("Taqvo")
                }
                .font(.caption)
                .foregroundColor(.white.opacity(0.9))
                .padding(.top, 8)
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .frame(width: 800, height: 450)

        let renderer = ImageRenderer(content: shareView)
        renderer.scale = 2
        let url = FileManager.default.temporaryDirectory.appendingPathComponent("taqvo-summary-\(Int(summary.endDate.timeIntervalSince1970)).png")
        if let uiImg = renderer.uiImage, let data = uiImg.pngData() {
            try? data.write(to: url)
        } else {
            // Guaranteed PNG fallback
            let size = CGSize(width: 800, height: 450)
            UIGraphicsBeginImageContextWithOptions(size, true, 2)
            UIColor.black.setFill()
            UIBezierPath(rect: CGRect(origin: .zero, size: size)).fill()
            let fallback = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            if let data = fallback?.pngData() { try? data.write(to: url) }
        }
        return url
    }

    @MainActor
    private func handleShareTap() async {
        if saveToHealth && health.authorized {
            let ok = await health.save(summary: summary)
            healthSaveMessage = ok ? "Saved to Health" : "Health save failed"
        }
        // Attempt to fetch average heart rate for intensity if authorized
        let avgHR = health.authorized ? await health.averageHeartRateBPM(start: summary.startDate, end: summary.endDate) : nil
        let trimmedTitle = activityTitle.trimmingCharacters(in: .whitespacesAndNewlines)
        let passedTitle = trimmedTitle.isEmpty ? nil : trimmedTitle
        store.add(summary: summary,
                  snapshot: snapshot,
                  note: note.isEmpty ? nil : note,
                  photo: selectedPhoto,
                  avgHeartRateBPM: avgHR,
                  title: passedTitle)
        dismiss()
    }
}

#Preview {
    PostRunSummaryView(summary: ActivitySummary(distanceMeters: 1234,
                                                durationSeconds: 456,
                                                route: [],
                                                routeSamples: [],
                                                startDate: Date(),
                                                endDate: Date(),
                                                kind: .run,
                                                caloriesKilocalories: 123))
}

// HealthKit sync service
@MainActor
final class HealthSyncService: ObservableObject {
    @Published private(set) var authorized: Bool = false
    private let store = HKHealthStore()

    func ensureAuthorization() async -> Bool {
        guard HKHealthStore.isHealthDataAvailable() else { return false }
        var share: Set<HKSampleType> = [HKObjectType.workoutType()]
        var read: Set<HKObjectType> = [HKObjectType.workoutType()]
        if let distWR = HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning) {
            share.insert(distWR)
            read.insert(distWR)
        }
        if let distCyc = HKQuantityType.quantityType(forIdentifier: .distanceCycling) {
            share.insert(distCyc)
            read.insert(distCyc)
        }
        if let energy = HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned) {
            share.insert(energy)
            read.insert(energy)
        }
        // Read heart rate for intensity (no sharing needed)
        if let hr = HKQuantityType.quantityType(forIdentifier: .heartRate) {
            read.insert(hr)
        }
        // Steps and floors
        if let steps = HKQuantityType.quantityType(forIdentifier: .stepCount) {
            read.insert(steps)
        }
        if let floorsUp = HKQuantityType.quantityType(forIdentifier: .flightsClimbed) {
            read.insert(floorsUp)
        }
        // Removed cadence quantity types to support broader SDKs; cadence will be derived from steps/time
        share.insert(HKSeriesType.workoutRoute())
        read.insert(HKSeriesType.workoutRoute())

        let success = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            store.requestAuthorization(toShare: share, read: read) { ok, _ in
                cont.resume(returning: ok)
            }
        }
        authorized = success
        return success
    }

    func save(summary: ActivitySummary) async -> Bool {
        if !authorized {
            let ok = await ensureAuthorization()
            guard ok else { return false }
        }

        // Configure type based on summary.kind
        let config = HKWorkoutConfiguration()
        switch summary.kind {
        case .walk: config.activityType = .walking
        case .jog, .run: config.activityType = .running
        case .ride: config.activityType = .cycling
        }

        let builder = HKWorkoutBuilder(healthStore: store, configuration: config, device: nil)

        let began = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            builder.beginCollection(withStart: summary.startDate) { ok, _ in cont.resume(returning: ok) }
        }
        guard began else { return false }

        // Distance
        let distanceQty = HKQuantity(unit: HKUnit.meter(), doubleValue: summary.distanceMeters)
        let distanceType: HKQuantityTypeIdentifier = (summary.kind == .ride) ? .distanceCycling : .distanceWalkingRunning
        if let distType = HKQuantityType.quantityType(forIdentifier: distanceType) {
            let sample = HKQuantitySample(type: distType, quantity: distanceQty, start: summary.startDate, end: summary.endDate)
            await withCheckedContinuation { (cont: CheckedContinuation<Void, Never>) in
                builder.add([sample]) { _, _ in
                    cont.resume()
                }
            }
        }

        // Active energy
        if let energyType = HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned) {
            let energyQty = HKQuantity(unit: HKUnit.kilocalorie(), doubleValue: summary.caloriesKilocalories)
            let sample = HKQuantitySample(type: energyType, quantity: energyQty, start: summary.startDate, end: summary.endDate)
            await withCheckedContinuation { (cont: CheckedContinuation<Void, Never>) in
                builder.add([sample]) { _, _ in
                    cont.resume()
                }
            }
        }

        // Route
        let routeBuilder = HKWorkoutRouteBuilder(healthStore: store, device: nil)
        let locs = HealthSyncService.locations(from: summary.route, start: summary.startDate, end: summary.endDate)
        do {
            try await routeBuilder.insertRouteData(locs)
        } catch {
            // intentionally ignore route errors
        }

        let finished = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            builder.endCollection(withEnd: summary.endDate) { ok, _ in cont.resume(returning: ok) }
        }
        guard finished else { return false }

        let saved = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            builder.finishWorkout { workout, error in
                cont.resume(returning: workout != nil)
            }
        }

        return saved
    }

    // Compute average heart rate (bpm) for a time range
    func averageHeartRateBPM(start: Date, end: Date) async -> Double? {
        guard authorized, let type = HKQuantityType.quantityType(forIdentifier: .heartRate) else { return nil }
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<Double?, Never>) in
            let q = HKSampleQuery(sampleType: type, predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: nil) { _, samples, _ in
                guard let samples = samples as? [HKQuantitySample], !samples.isEmpty else {
                    cont.resume(returning: nil)
                    return
                }
                let unit = HKUnit.count().unitDivided(by: HKUnit.minute())
                let total = samples.reduce(0.0) { $0 + $1.quantity.doubleValue(for: unit) }
                cont.resume(returning: total / Double(samples.count))
            }
            self.store.execute(q)
        }
    }

    // Steps count for a time range
    func stepCount(start: Date, end: Date) async -> Int? {
        guard authorized, let type = HKQuantityType.quantityType(forIdentifier: .stepCount) else { return nil }
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<Int?, Never>) in
            let q = HKStatisticsQuery(quantityType: type, quantitySamplePredicate: predicate, options: .cumulativeSum) { _, stats, _ in
                let count = stats?.sumQuantity()?.doubleValue(for: HKUnit.count())
                cont.resume(returning: count.map { Int($0) })
            }
            self.store.execute(q)
        }
    }

    // Average cadence (steps per minute) for a time range, derived from steps/duration
    func averageCadenceSPM(start: Date, end: Date) async -> Double? {
        guard authorized else { return nil }
        if let steps = await stepCount(start: start, end: end) {
            let minutes = max(end.timeIntervalSince(start) / 60.0, 0.001)
            return Double(steps) / minutes
        }
        return nil
    }

    // Elevation gain estimate using flights climbed (approx 3.0 m per floor)
    func elevationGainMeters(start: Date, end: Date) async -> Double? {
        guard authorized, let type = HKQuantityType.quantityType(forIdentifier: .flightsClimbed) else { return nil }
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<Double?, Never>) in
            let q = HKStatisticsQuery(quantityType: type, quantitySamplePredicate: predicate, options: .cumulativeSum) { _, stats, _ in
                if let floors = stats?.sumQuantity()?.doubleValue(for: HKUnit.count()) {
                    cont.resume(returning: floors * 3.0)
                } else { cont.resume(returning: nil) }
            }
            self.store.execute(q)
        }
    }

    // Import past workouts from Apple Health and convert to ActivitySummary objects
    func importWorkouts(daysBack: Int) async -> [ActivitySummary] {
        if !authorized {
            let ok = await ensureAuthorization()
            guard ok else { return [] }
        }
        let end = Date()
        let start = Calendar.current.date(byAdding: .day, value: -daysBack, to: end) ?? end.addingTimeInterval(-Double(daysBack) * 86400)
        let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: [])
        return await withCheckedContinuation { (cont: CheckedContinuation<[ActivitySummary], Never>) in
            let q = HKSampleQuery(sampleType: HKObjectType.workoutType(), predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: nil) { _, samples, _ in
                guard let workouts = samples as? [HKWorkout] else {
                    cont.resume(returning: [])
                    return
                }
                Task {
                    let results = await withTaskGroup(of: ActivitySummary?.self) { group in
                        for w in workouts {
                            group.addTask {
                                let kind: ActivityKind
                                switch w.workoutActivityType {
                                case .walking: kind = .walk
                                case .running: kind = .run
                                case .cycling: kind = .ride
                                default: kind = .run
                                }
                                let meters = w.totalDistance?.doubleValue(for: HKUnit.meter()) ?? 0
                                let kcal: Double
                                if #available(iOS 18.0, *) {
                                    if let type = HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned) {
                                        let stats = w.statistics(for: type)
                                        kcal = stats?.sumQuantity()?.doubleValue(for: HKUnit.kilocalorie()) ?? 0
                                    } else {
                                        kcal = 0
                                    }
                                } else {
                                    kcal = w.totalEnergyBurned?.doubleValue(for: HKUnit.kilocalorie()) ?? 0
                                }
                                let (coords, samples) = await self.routeForWorkout(w)
                                return ActivitySummary(distanceMeters: meters,
                                                      durationSeconds: w.duration,
                                                      route: coords,
                                                      routeSamples: samples,
                                                      startDate: w.startDate,
                                                      endDate: w.endDate,
                                                      kind: kind,
                                                      caloriesKilocalories: kcal)
                            }
                        }
                        var collected: [ActivitySummary] = []
                        for await item in group {
                            if let sum = item { collected.append(sum) }
                        }
                        return collected
                    }
                    cont.resume(returning: results)
                }
            }
            self.store.execute(q)
        }
    }

    private func routeForWorkout(_ workout: HKWorkout) async -> ([CLLocationCoordinate2D], [RouteSample]) {
        guard authorized else { return ([], []) }
        let predicate = HKQuery.predicateForObjects(from: workout)
        return await withCheckedContinuation { (cont: CheckedContinuation<([CLLocationCoordinate2D], [RouteSample]), Never>) in
            let q = HKSampleQuery(sampleType: HKSeriesType.workoutRoute(), predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: nil) { _, samples, _ in
                guard let routes = samples as? [HKWorkoutRoute], !routes.isEmpty else {
                    cont.resume(returning: ([], []))
                    return
                }
                var allLocations: [CLLocation] = []
                let group = DispatchGroup()
                for route in routes {
                    group.enter()
                    var routeLocations: [CLLocation] = []
                    let rq = HKWorkoutRouteQuery(route: route) { _, locs, done, _ in
                        if let locs = locs { routeLocations.append(contentsOf: locs) }
                        if done {
                            allLocations.append(contentsOf: routeLocations)
                            group.leave()
                        }
                    }
                    self.store.execute(rq)
                }
                group.notify(queue: .main) {
                    let coords = allLocations.map { $0.coordinate }
                    let samples = allLocations.map { RouteSample(latitude: $0.coordinate.latitude, longitude: $0.coordinate.longitude, timestamp: $0.timestamp) }
                    cont.resume(returning: (coords, samples))
                }
            }
            self.store.execute(q)
        }
    }

    private static func locations(from coords: [CLLocationCoordinate2D], start: Date, end: Date) -> [CLLocation] {
        guard !coords.isEmpty else { return [] }
        let per = max(1, Int((end.timeIntervalSince(start)) / Double(max(coords.count, 1))))
        var result: [CLLocation] = []
        var t = start
        for c in coords {
            result.append(CLLocation(coordinate: c, altitude: 0, horizontalAccuracy: 10, verticalAccuracy: 10, timestamp: t))
            t = t.addingTimeInterval(TimeInterval(per))
        }
        return result
    }
}