//
//  PostRunSummaryView.swift
//  Taqvo
//
//  Generated by Assistant on 10/17/25
//

import SwiftUI
import MapKit
import PhotosUI
import HealthKit

struct PostRunSummaryView: View {
    let summary: ActivitySummary
    @State private var snapshot: UIImage?
    @EnvironmentObject private var store: ActivityStore
    @Environment(\.dismiss) private var dismiss
    @State private var note: String = ""
    @State private var selectedPhotoItem: PhotosPickerItem?
    @State private var selectedPhoto: UIImage?
    @StateObject private var health = HealthSyncService()
    @State private var saveToHealth: Bool = UserDefaults.standard.bool(forKey: "healthSyncEnabled")
    @State private var healthSaveMessage: String?

    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                if let img = snapshot {
                    Image(uiImage: img)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .cornerRadius(12)
                } else {
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 220)
                        .overlay(Text("Generating mapâ€¦").foregroundColor(.taqvoAccentText))
                        .cornerRadius(12)
                }

                if let photo = selectedPhoto {
                    Image(uiImage: photo)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .cornerRadius(12)
                }

                // Note input
                VStack(alignment: .leading, spacing: 8) {
                    Text("Add a note")
                        .font(.caption)
                        .foregroundColor(.taqvoAccentText)
                    TextField("How did it feel?", text: $note, axis: .vertical)
                        .textFieldStyle(.roundedBorder)
                        .lineLimit(3...6)
                }

                // Photo picker
                PhotosPicker(selection: $selectedPhotoItem, matching: .images, photoLibrary: .shared()) {
                    HStack {
                        Image(systemName: "photo")
                        Text(selectedPhoto == nil ? "Add a photo" : "Change photo")
                    }
                    .font(.headline)
                    .foregroundColor(.black)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.white.opacity(0.85))
                    .cornerRadius(16)
                }
                .onChange(of: selectedPhotoItem) { _, newItem in
                    Task {
                        if let item = newItem {
                            do {
                                if let data: Data = try await item.loadTransferable(type: Data.self) {
                                    if let img = UIImage(data: data) {
                                        await MainActor.run { selectedPhoto = img }
                                    }
                                }
                            } catch {
                                // silently ignore photo load errors
                            }
                        }
                    }
                }

                // Save to Apple Health toggle
                VStack(alignment: .leading, spacing: 8) {
                    Toggle(isOn: $saveToHealth) {
                        HStack {
                            Image(systemName: "heart.fill").foregroundColor(.red)
                            Text("Save to Apple Health")
                        }
                    }
                    .disabled(!health.authorized)
                    .tint(.taqvoCTA)

                    if !health.authorized {
                        Text("Enable Health access in Settings to save workouts.")
                            .font(.caption)
                            .foregroundColor(.taqvoAccentText)
                    }
                    if let msg = healthSaveMessage, !msg.isEmpty {
                        Text(msg)
                            .font(.caption)
                            .foregroundColor(.taqvoAccentText)
                    }
                }
                .onChange(of: saveToHealth) { _, newVal in
                    UserDefaults.standard.set(newVal, forKey: "healthSyncEnabled")
                }

                Button {
                    Task { @MainActor in
                        await handleShareTap()
                    }
                } label: {
                    Text("Share to Feed")
                        .font(.headline)
                        .foregroundColor(.black)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.taqvoCTA)
                        .cornerRadius(16)
                }
            }
            .padding()
        }
        .onAppear {
            generateSnapshot()
        }
        .task { @MainActor in
            let ok = await health.ensureAuthorization()
            if ok && UserDefaults.standard.object(forKey: "healthSyncEnabled") == nil {
                saveToHealth = true
                UserDefaults.standard.set(true, forKey: "healthSyncEnabled")
            }
        }
        .navigationTitle("Summary")
        .background(Color.taqvoBackgroundDark)
    }

    private func metric(_ title: String, _ value: String) -> some View {
        VStack {
            Text(title).foregroundColor(.taqvoAccentText).font(.caption)
            Text(value).foregroundColor(.taqvoTextDark).font(.title3).monospacedDigit()
        }
        .frame(maxWidth: .infinity)
        .padding(8)
        .background(Color.black.opacity(0.2))
        .cornerRadius(12)
    }

    private func generateSnapshot() {
        guard summary.route.count > 0 else { return }
        let polyline = MKPolyline(coordinates: summary.route, count: summary.route.count)
        let rect = polyline.boundingMapRect
        let region = MKCoordinateRegion(rect)

        let options = MKMapSnapshotter.Options()
        options.region = region
        options.size = CGSize(width: 600, height: 300)
        options.scale = UIScreen.main.scale
        options.showsBuildings = true
        options.mapType = .standard

        let snapshotter = MKMapSnapshotter(options: options)
        snapshotter.start { result, error in
            guard let snapshot = result else { return }
            let image = snapshot.image
            UIGraphicsBeginImageContextWithOptions(image.size, true, image.scale)
            image.draw(at: .zero)

            let path = UIBezierPath()
            for (i, coord) in summary.route.enumerated() {
                let point = snapshot.point(for: coord)
                if i == 0 { path.move(to: point) } else { path.addLine(to: point) }
            }
            UIColor.systemGreen.setStroke()
            path.lineWidth = 4
            path.stroke()

            let final = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            DispatchQueue.main.async { self.snapshot = final }
        }
    }

    @MainActor
    private func handleShareTap() async {
        if saveToHealth && health.authorized {
            let ok = await health.save(summary: summary)
            healthSaveMessage = ok ? "Saved to Health" : "Health save failed"
        }
        store.add(summary: summary,
                  snapshot: snapshot,
                  note: note.isEmpty ? nil : note,
                  photo: selectedPhoto)
        dismiss()
    }
}

#Preview {
    PostRunSummaryView(summary: ActivitySummary(distanceMeters: 1234,
                                                durationSeconds: 456,
                                                route: [],
                                                startDate: Date(),
                                                endDate: Date()))
}

// HealthKit sync service
@MainActor
final class HealthSyncService: ObservableObject {
    @Published private(set) var authorized: Bool = false
    private let store = HKHealthStore()

    func ensureAuthorization() async -> Bool {
        guard HKHealthStore.isHealthDataAvailable() else { return false }
        var share: Set<HKSampleType> = [HKObjectType.workoutType()]
        var read: Set<HKObjectType> = [HKObjectType.workoutType()]
        if let dist = HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning) {
            share.insert(dist)
            read.insert(dist)
        }
        share.insert(HKSeriesType.workoutRoute())
        read.insert(HKSeriesType.workoutRoute())

        let success = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
            store.requestAuthorization(toShare: share, read: read) { ok, _ in
                cont.resume(returning: ok)
            }
        }
        authorized = success
        return success
    }

    func save(summary: ActivitySummary) async -> Bool {
        if !authorized {
            let ok = await ensureAuthorization()
            guard ok else { return false }
        }

        let distanceQty = HKQuantity(unit: HKUnit.meter(), doubleValue: summary.distanceMeters)
        // Use HKWorkoutBuilder (iOS 17+ recommended) to create and save workout
        let config = HKWorkoutConfiguration()
        config.activityType = .running
        let builder = HKWorkoutBuilder(healthStore: store, configuration: config, device: nil)
        // Begin and end collection with summary start/end
        let began = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
        builder.beginCollection(withStart: summary.startDate) { ok, _ in cont.resume(returning: ok) }
        }
        guard began else { return false }
        // Add a distance sample to the builder for the workout
        if let distType = HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning) {
        let sample = HKQuantitySample(type: distType,
        quantity: distanceQty,
        start: summary.startDate,
        end: summary.endDate)
        _ = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
        builder.add([sample]) { ok, _ in cont.resume(returning: ok) }
        }
        }
        let ended = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
        builder.endCollection(withEnd: summary.endDate) { ok, _ in cont.resume(returning: ok) }
        }
        guard ended else { return false }
        let workout = await withCheckedContinuation { (cont: CheckedContinuation<HKWorkout?, Never>) in
        builder.finishWorkout { wk, _ in cont.resume(returning: wk) }
        }
        guard let workout = workout else { return false }
         
        // Distance samples added to the workout builder are persisted with the workout.
        // Avoid saving a duplicate standalone distance sample to improve reliability.
         
        if summary.route.count >= 2 {
            let builder = HKWorkoutRouteBuilder(healthStore: store, device: nil)
            let locs = Self.locations(from: summary.route, start: summary.startDate, end: summary.endDate)
            let inserted = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
                builder.insertRouteData(locs) { ok, _ in cont.resume(returning: ok) }
            }
            guard inserted else { return true }
        
            let finished = await withCheckedContinuation { (cont: CheckedContinuation<Bool, Never>) in
                builder.finishRoute(with: workout, metadata: nil) { _, error in
                    cont.resume(returning: (error == nil))
                }
            }
            return finished
        }
 
        return true
    }

    private static func locations(from coords: [CLLocationCoordinate2D], start: Date, end: Date) -> [CLLocation] {
        guard coords.count > 0 else { return [] }
        let total = end.timeIntervalSince(start)
        let count = max(coords.count - 1, 1)
        return coords.enumerated().map { (i, c) in
            let ts = start.addingTimeInterval(total * Double(i) / Double(count))
            return CLLocation(coordinate: c,
                              altitude: 0,
                              horizontalAccuracy: 10,
                              verticalAccuracy: 10,
                              timestamp: ts)
        }
    }
}